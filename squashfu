#!/bin/bash

CONFIG="/etc/squashfu.conf"
source "$CONFIG"

# Informational output w/ happy colors
debug () {
    [[ $DEBUG ]] && echo -e '\033[1;33mDEBUG ::\033[1;m ' $*
}

info () {
    echo -e '\033[1;34m::\033[1;m ' $*
}

die () {
    echo -e '\033[1;31mFATAL ::\033[1;m ' $* >&2
    exit 1
}

mount_squash () {
# Arguments: none
# Returns: return code of mount command
    debug "Mounting Squash"
    mount -o loop,ro "$SEED" "${BKUP_ROOT}/ro"
    return $?
}

mount_union_with_bins () {
# Arguments: numbers of bins to be mounted (variable number)
# Returns: 0 on successful mount, non-zero on failure
    debug "Requested to mount bins: $*"

    # Mount first as rw, shift, and mount the rest ro
    branches="br=${BINS_DIR}/$1=rw:"; shift
    if [[ -n $1 ]]; then
        for bin in $*; do
            branches="${branches}${BINS_DIR}/$bin=ro:"
        done
    fi
    branches="${branches}${BKUP_ROOT}/ro=ro"

    debug "mount -t aufs none "${BKUP_ROOT}/rw" -o udba=reval,$branches"
    mount -t aufs none "${BKUP_ROOT}/rw" -o udba=reval,$branches

    return $?
}

get_next_available_bin () {
# Arguments: none
# Returns: Numeric value of the next unused bin
    next_bin=$[ $(cut -d: -f1 "$BINVENTORY" | sort -n | tail -1) + 1 ]
    debug "Next available bin = $next_bin"
    return $next_bin
}

sweep_bins () {
# Arguments: none
# Returns: none
    count=1

    # Make sure bins are numbered in order, clean up if not. In other words,
    # if we have 10 bins, make sure they're ordered 1 through 10.
    for bin in "${BINS_DIR}/*"; do
        if [[ ! -d "${BINS_DIR}/$count" ]]; then
            high_bin=$(ls "${BINS_DIR}" | sort -n | tail -1)
            mv "${BINS_DIR}/$high_bin" "${BINS_DIR}/$count"
            sed -i "/^$high_bin:/s/^$high_bin:/$count:/" "$BINVENTORY"
        fi
        count=$[ $count + 1 ]
    done

}

call_rsync () {
# Arguments: none
# Returns: return code from rsync

    # Parse includes and excludes from heredocs in config
    INCLUDES=($(sed -n '/^<<INCLUDES$/,/^INCLUDES$/p' $CONFIG | grep -vE "^<*INCLUDES$"))
    EXCLUDES=($(sed -n '/^<<EXCLUDES$/,/^EXCLUDES$/p' $CONFIG | \
                grep -vE "^<*EXCLUDES$" | \
                sed -n 's/\(.*\)/--exclude "\1"/p'))

    # rsync source to $BKUP_ROOT/rw
    debug "Rsync executing with:"
    debug ":   Options: ${RSYNC_OPTS[@]}"
    debug ":   Includes: ${INCLUDES[@]}"
    debug ":   Excludes: ${EXCLUDES[@]}"
    rsync ${RSYNC_OPTS[@]} ${INCLUDES[@]} ${EXCLUDES[@]} "${BKUP_ROOT}/rw"
    return $?
}

create_new_bin () {
# Arguments: 1, the number of the bin to create
# Returns: 0 on success, non-zero on error

    debug "Asked to create new bin: $1"
    # Create new directory, fail if it exists (something's wrong)
    mkdir "${BINS_DIR}/$1"
    if [[ $? -ne 0 ]]; then
        return $?
    fi

    # Update binventory with new bin name and timestamp
    debug "Updating $BINVENTORY, adding bin $1"
    echo "${1}:$(date +%s)" >> "$BINVENTORY"

    # If write to bin list fails, remove diretory and exit
    if [[ $? -ne 0 ]]; then
        rmdir "${BINS_DIR}/${1}"
        die "Error writing to '$BINVENTORY'"
    fi

    return
}

# Unmounting functions
unmount_union () {
# Args: none
# Returns: return code from umount
    debug "Unmounting union"
    while [[ $(mountpoint "${BKUP_ROOT}/rw" | grep "is a mount") ]]; do
        umount "${BKUP_ROOT}/rw" 2>/dev/null
        sleep 1
    done
    return $?
}

unmount_squash () {
# Args: none
# Returns: return code from umount
    debug "Unmounting squash"
    while [[ $(mountpoint "${BKUP_ROOT}/ro" | grep "is a mount") ]]; do
        umount "${BKUP_ROOT}/ro" 2>/dev/null
        sleep 1
    done
    return $?
}

unmount_all () {
# Args: none
# Returns: none

    # Union MUST be unmounted first
    unmount_union
    unmount_squash
}

check_for_resquash () {
# Args: none
# Returns: number of bins needing to be merged
    local number_of_bins=$(wc -l "$BINVENTORY" | cut -d\  -f1)
    debug "Found $number_of_bins bins"

    if [[ $number_of_bins -gt $MAX_BINS ]]; then
        return $[ $number_of_bins - $MIN_BINS ]
    else
        return 0
    fi
}

create_new_squash () {
# Args: number of bins to be squashed (as determined by check_for_resquash), -1 on initial creation
# Returns: 0 on success, non-zero on failure

    # If making first seed, create it empty and return
    if [[ $1 -eq -1 ]]; then
        mksquashfs "${BKUP_ROOT}/rw" "$SEED" -b 65536
        return $?
    fi

    # Determine oldest $1 bins and mount them with the current squash
    local old_bins=($(sort -n -r -t: -k2 "$BINVENTORY" | tail -$1 | cut -d: -f1))

    mount_union_with_bins ${old_bins[@]}

    # Create new squash with temp name
    mksquashfs "${BKUP_ROOT}/rw" "$SEED.replace" -b 65536

    # If the squash wasn't made correctly, we don't want to continue
    if [[ $? -ne 0 ]]; then
        return 1
    fi

    unmount_all

    # Replace old squash
    mv "${SEED}.replace" "$SEED"

    # Delete old bins, and remove entry from binventory
    for bin in $old_bins; do
        rm -rf "${BINS_DIR}/$bin"
        sed -i "/^$bin:/d" "$BINVENTORY"
    done
}

create_new_incremental () {
# Args: none
# Returns: 0 on success, non-zero on error

    # Make a new bin for this incremenetal
    get_next_available_bin
    create_new_bin $?

    # Determine the mount order via binventory
    bin_order=($(sort -n -r -t: -k2 "$BINVENTORY" | cut -d: -f1))

    mount_squash
    mount_union_with_bins ${bin_order[@]}

    # Die with error on mount, else start rsync
    if [[ $? -ne 0 ]]; then
        return 1;
    fi

    call_rsync

    return $?
}

action_backup () {
# Args: options array squashfu was invoked with, shifted 1
# Returns: none

    # Does the binventory exist? If not, prompt to make sure this is an initialization
    FIRST_RUN=0
    if [[ ! -f "$BINVENTORY" || ! -f "$SEED" ]]; then
        read -p "Looks like this is your first time running SquashFu. Is this correct? (y/n) " ans
        while [[ true ]]; do
            case $ans in
                [yY]) break ;;
                [nN]) die "Your bin inventory and/or seed seem to be missing. Please fix this before continuing." ;;
                *) ;;
            esac
        done

        # If we got here, the user answered yes, so initialize a new structure
        mkdir -p "${BKUP_ROOT}/rw"
        mkdir -p "${BKUP_ROOT}/ro"
        mkdir -p "${BINS_DIR}"
        touch "$BINVENTORY"
        create_new_squash -1
        FIRST_RUN=1
    fi

    create_new_incremental

    check_for_resquash
    if [[ val=$? -gt 0 ]]; then
        create_new_squash $val
    elif [[ $FIRST_RUN -eq 1 ]]; then
        create_new_squash 1
    fi

    # TODO: Report if requested

    unmount_all
}

action_rollback () {
    debug "IOU: one rollback";exit 0
    # Validate input
    # call mount_squash
    # call mount_union_with_bins


}

action_report () {
    debug "IOU: one status report"; exit 0
    # Enumerate bins, sort by order, provide size and convert timestamp to human readable
    #   use $(date --date="1970-01-01 $TIMESTAMP sec GMT")

}

action_backup

