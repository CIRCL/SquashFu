#!/bin/bash

CONFIG="/etc/squashfu.conf"
source "$CONFIG"

# Informational output w/ happy colors
debug () {
    if [[ $DEBUG ]]; then
        echo -e '\033[1;33mDEBUG ::\033[1;m ' $*
    fi
}

info () {
    echo -e '\033[1;34m::\033[1;m ' $*
}

die () {
    echo -e '\033[1;31mFATAL ::\033[1;m ' $* >&2
    exit 1
}

mount_squash () {
# Arguments: none
# Returns: return code of mount command
    debug "Mounting Squash"
    mount -o loop,ro "$SEED" "${BKUP_ROOT}/ro"
    return $?
}

mount_union_with_bins () {
# Arguments: numbers of bins to be mounted (variable number)
# Returns: 0 on successful mount, non-zero on failure
    debug "Requested to mount bins: $*"

    # Mount first as rw, shift, and mount the rest ro
    branches="br=${BINS_DIR}/$1=rw:"; shift
    if [[ -n $1 ]]; then
        for bin in $*; do
            branches="${branches}${BINS_DIR}/$bin=ro:"
        done
    fi
    branches="${branches}${BKUP_ROOT}/ro=ro"

    debug "mount -t aufs none "${BKUP_ROOT}/rw" -o udba=reval,$branches"
    mount -t aufs none "${BKUP_ROOT}/rw" -o udba=reval,$branches

    return $?
}

get_next_available_bin () {
# Arguments: none
# Returns: Numeric value of the next unused bin
    next_bin=$[ $(cut -d: -f1 "$BINVENTORY" | sort -n | tail -1) + 1 ]
    debug "Next available bin = $next_bin"
    return $next_bin
}

sweep_bins () {
# Arguments: none
# Returns: none
    debug "Entering sweep_bins"
    count=1

    # Make sure bins are numbered in order, clean up if not. In other words,
    # if we have 10 bins, make sure they're ordered 1 through 10.
    ls "${BINS_DIR}" | while read bin; do
    #for bin in "${BINS_DIR}/*"; do
        if [[ ! -d "${BINS_DIR}/$count" ]]; then
            high_bin=$(ls "${BINS_DIR}" | sort -n | tail -1)
            mv "${BINS_DIR}/$high_bin" "${BINS_DIR}/$count"
            sed -i "/^$high_bin:/s/^$high_bin:/$count:/" "$BINVENTORY"
        fi
        count=$[ $count + 1 ]
    done
    debug "Leaving sweep_bins"
    ls "$BINS_DIR"

}

call_rsync () {
# Arguments: none
# Returns: return code from rsync

    # Parse includes and excludes from heredocs in config
    INCLUDES=($(sed -n '/^<<INCLUDES$/,/^INCLUDES$/p' $CONFIG | grep -vE "^<*INCLUDES$"))
    EXCLUDES=($(sed -n '/^<<EXCLUDES$/,/^EXCLUDES$/p' $CONFIG | \
                grep -vE "^<*EXCLUDES$" | \
                sed -n 's/\(.*\)/--exclude "\1"/p'))

    # rsync source to $BKUP_ROOT/rw
#    debug "Rsync executing with:"
#    debug ":   Options: ${RSYNC_OPTS[@]}"
#    debug ":   Includes: ${INCLUDES[@]}"
#    debug ":   Excludes: ${EXCLUDES[@]}"
    debug "rsync ${RSYNC_OPTS[@]} ${INCLUDES[@]} ${EXCLUDES[@]} "${BKUP_ROOT}/rw""
    rsync ${RSYNC_OPTS[@]} ${INCLUDES[@]} ${EXCLUDES[@]} "${BKUP_ROOT}/rw"
    return $?
}

create_new_bin () {
# Arguments: 1, the number of the bin to create
# Returns: 0 on success, non-zero on error

    debug "Asked to create new bin: $1"
    # Create new directory, fail if it exists (something's wrong)
    mkdir "${BINS_DIR}/$1"
    if [[ $? -ne 0 ]]; then
        return $?
    fi

    # Update binventory with new bin name and timestamp
    debug "Updating $BINVENTORY, adding bin $1"
    echo "${1}:$(date +%s)" >> "$BINVENTORY"

    # If write to bin list fails, remove diretory and exit
    if [[ $? -ne 0 ]]; then
        rmdir "${BINS_DIR}/${1}"
        die "Error writing to '$BINVENTORY'"
    fi

    return
}

# Unmounting functions
unmount_union () {
# Args: none
# Returns: return code from umount
    debug "Unmounting union"
    while [[ $(mountpoint "${BKUP_ROOT}/rw" | grep "is a mount") ]]; do
        umount "${BKUP_ROOT}/rw" 2>/dev/null
        sleep 1
    done
    return $?
}

unmount_squash () {
# Args: none
# Returns: return code from umount
    debug "Unmounting squash"
    while [[ $(mountpoint "${BKUP_ROOT}/ro" | grep "is a mount") ]]; do
        umount "${BKUP_ROOT}/ro" 2>/dev/null
        sleep 1
    done
    return $?
}

unmount_all () {
# Args: none
# Returns: none

    # Union MUST be unmounted first
    unmount_union
    unmount_squash
}

check_for_resquash () {
# Args: none
# Returns: number of bins needing to be merged
    local number_of_bins=$(grep -vE "^[ ]*$" "$BINVENTORY" | wc -l)
    debug "Found $number_of_bins bins"

    if [[ $number_of_bins -gt $MAX_BINS ]]; then
        return $[ $number_of_bins - $MIN_BINS ]
    else
        return 0
    fi
}

create_new_squash () {
# Args: number of bins to be squashed (as determined by check_for_resquash), -1 on initial creation
# Returns: 0 on success, non-zero on failure

    # If making first seed, create it empty and return
    if [[ $1 -eq -1 ]]; then
        mksquashfs "${BKUP_ROOT}/rw" "$SEED" -b 65536
        return $?
    fi

    # Determine oldest $1 bins and mount them with the current squash
    local old_bins=($(sort -n -r -t: -k2 "$BINVENTORY" | tail -$1 | cut -d: -f1))

    debug "old_bins declared as: ${old_bins[@]}"

    mount_union_with_bins ${old_bins[@]}

    # Create new squash with temp name
    mksquashfs "${BKUP_ROOT}/rw" "$SEED.replace" -b 65536

    # If the squash wasn't made correctly, we don't want to continue
    if [[ $? -ne 0 ]]; then
        return 1
    fi

    unmount_all

    # Replace old squash
    mv "${SEED}.replace" "$SEED"

    # Delete old bins, and remove entry from binventory
    for bin in ${old_bins[@]}; do
        rm -rf "${BINS_DIR}/$bin"
        sed -i "/^$bin:/d" "$BINVENTORY"
    done

    # Clean up $binventory
    sweep_bins
}

create_new_incremental () {
# Args: none
# Returns: 0 on success, non-zero on error

    # Make a new bin for this incremenetal
    get_next_available_bin
    create_new_bin $?

    # Determine the mount order via binventory
    local bin_order=($(sort -n -r -t: -k2 "$BINVENTORY" | cut -d: -f1))

    mount_squash
    mount_union_with_bins ${bin_order[@]}

    # Die with error on mount, else start rsync
    if [[ $? -ne 0 ]]; then
        return 1;
    fi

    call_rsync

    return $?
}

action_backup () {
# Args: options array squashfu was invoked with, shifted 1
# Returns: none

    # Does the binventory exist? If not, prompt to make sure this is an initialization
    # FIRST_RUN=0
    if [[ ! -f "$BINVENTORY" || ! -f "$SEED" ]]; then
        read -p "Looks like this is your first time running SquashFu. Is this correct? (y/n) " ans
        while [[ true ]]; do
            case $ans in
                [yY]) break ;;
                [nN]) die "Your bin inventory and/or seed seem to be missing. Please fix this before continuing." ;;
                *) ;;
            esac
        done

        # If we got here, the user answered yes, so initialize a new structure
        mkdir -p "${BKUP_ROOT}/rw"
        mkdir -p "${BKUP_ROOT}/ro"
        mkdir -p "${BINS_DIR}"
        touch "$BINVENTORY"
        create_new_squash -1
        FIRST_RUN=1
    fi

    create_new_incremental

    check_for_resquash
    if [[ val=$? -gt 0 ]]; then
        create_new_squash $val
    elif [[ $FIRST_RUN -eq 1 ]]; then
        create_new_squash 1
    fi

    # TODO: Report if requested

    unmount_all
}

action_rollback () {
    debug "IOU: one rollback";exit 0
    # Validate input with test cases
    if [[ -z $1 ]]; then
        die "The rollback action requires 1 additional argument."
    fi

    if [[ $1 -le 0 ]]; then
        die "Please provide a positive number of backups to roll back"
    fi

    # Form a chronologically ordered list of bins, assuming the user didn't give bogus input
    local bin_list=($(grep -vE "^[ ]*$" "$BINVENTORY" | sort -t: -n -k2 | cut -d: -f1))

    if [[ $1 -gt $number_of_bins ]]; then
        die "Cannot rollback more than ${#number_of_bins[@]} backups"
    fi

    local num_to_mount=$[ ${#number_of_bins[@]} - $1 ]

    call mount_squash

    call mount_union_with_bins ${bin_list[@]:0:$num_to_mount}

    info "Union is now mounted at '${BKUP_ROOT}/rw'"

}

action_report () {
    debug "IOU: one status report"; exit 0
    # Enumerate bins, sort by order, provide size and convert timestamp to human readable
    #   use $(date --date="1970-01-01 $TIMESTAMP sec GMT")

}

case $1 in
    "-B") action_backup ;;
    "-R") shift, action_rollback ;;
    *) "Invalid action" ;;
esac

